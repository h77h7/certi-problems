/**************
기존 타일채우기의 변형 : 중간에 빈칸이 있음
타일 채우기
2018/10/13 SW 검정 Pro
문제
높이가 3, 너비가 N 인 벽이 있다. N 은홀수이며 이 벽을 1*2 크기의 타일로 빈틈없이 채우고자 한다. 단,
이 벽에는 한 칸의 빈 공간이 있어서 해당 공간만 빼고 모든 공간을 채워야 한다.
타일의 방향은 가로, 세로 상관없다.
벽의 너비와 빈 공간의 좌표가 주어질 때 타일로 벽을 꽉 채울 수 있는 모든 경우의 수를 구하여라.

입력.
입력의 첫 줄에는 테스트 케이스의 개수 T 가 주어진다.
그 다음 줄부터 각각의 테스트 케이스에 대해 정수 N 과 빈 공간의 좌표 X, Y 가 주어진다.
(1≤N≤1000000, 1≤X≤N, 1≤Y≤3)

출력
각 테스트 케이스에 대해 출력한 값을 100000007 로 나눴을 때의 나머지 값을 출력한다.
(제한시간 1.5 초)
Input
7
5 3 3
7 4 2
11 5 1
51 4 1
1385 1 1
9999 7451 3
542153 245672 2
Output
#1 15
#2 32
#3 780
#4 0
#5 9445589
#6 51460180
#7 56955289
*********************/
#include <iostream>

using namespace std;

const int MAX_N = 1000000;
const int key = 100000007;

int f[MAX_N + 1] = { 0 };
int g[MAX_N + 1][2] = { 0 };

int main() {
	int tc;
	scanf("%d", &tc);

	for (int t = 1; t <= tc; t++) {
		int n, x, y;
		scanf("%d %d %d", &n, &x, &y);

		f[0] = 1;
		f[1] = 0;
		g[0][0] = 0;
		g[1][0] = 1;

		for (int i = 2; i < x; i++) {
			f[i] = (g[i - 1][0] * 2 + f[i - 2])%key;
			g[i][0] = (f[i - 1] + g[i - 2][0])%key;
		}

		if ((y == 2 && x & 1) || ((y == 1 || y == 3) && !(x & 1))) {
			printf("#%d 0\n", t);
			continue;
		}

		else if (y == 2) {

			f[x] = 0;
			g[x][0] = g[x - 1][0];
			f[x + 1] = (g[x - 1][0] * 2)%key;
			g[x + 1][0] = 0;

			for (int i = x + 2; i <= n; i++) {
				f[i] = (2 * g[i - 1][0] + f[i - 2])%key;
				g[i][0] = (f[i - 1] + g[i - 2][0])%key;
			}
		}
		else {
			if (x == 1) {
				f[x] = 1;
				g[x][0] = 0;
				f[x+1] = 0;
				g[x+1][0] = 2;
				g[x+1][1] = 1;
			}
			
			else {
				f[x] = (f[x - 1] + g[x - 2][0])%key;
				g[x][0] = 0;
				f[x + 1] = 0;
				g[x + 1][0] = (f[x] + f[x - 1])%key;
				g[x + 1][1] = f[x];
			}

			for (int i = x + 2; i <= n; i++) {
				f[i] = (g[i - 1][0] + g[i - 1][1] + f[i - 2])%key;
				g[i][0] = (f[i - 1] + g[i - 2][0])%key;
				g[i][1] = (f[i - 1] + g[i - 2][1])%key;
			}
		}

		printf("#%d %d\n", t, f[n]);
	}

	return 0;
}
